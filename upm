#!/usr/bin/env bash
set -euo pipefail

# upm - Uptime Monitor
# Tracks system uptime across multiple days with burn level analysis

readonly UPM_DIR="${HOME}/.upm"
readonly LOG_FILE="${UPM_DIR}/uptime.log"
readonly DAILY_ACCUMULATOR="${UPM_DIR}/daily_accumulator"
readonly CURRENT_SESSION_STATE="${UPM_DIR}/current_session_state"

# Colors for burn levels
readonly COLOR_RESET='\e[0m'
readonly COLOR_GREEN='\e[0;32m'
readonly COLOR_YELLOW='\e[0;33m'
readonly COLOR_ORANGE='\e[0;38;5;208m'
readonly COLOR_RED='\e[0;31m'
readonly COLOR_DARK_RED='\e[0;38;5;88m'

# Initialize directory structure
init_upm() {
    mkdir -p "${UPM_DIR}"
    touch "${LOG_FILE}"
    touch "${DAILY_ACCUMULATOR}"
    touch "${CURRENT_SESSION_STATE}"
}

# Get accumulated uptime for the current day (including previous boots)
get_daily_accumulated_time() {
    local current_date
    current_date=$(date +%Y-%m-%d)

    if [ -f "$DAILY_ACCUMULATOR" ] && [ -s "$DAILY_ACCUMULATOR" ]; then
        local stored_date stored_accumulated
        # Read the stored date and accumulated time
        IFS=' ' read -r stored_date stored_accumulated < "$DAILY_ACCUMULATOR"

        # If stored date is different from current date, reset accumulator
        if [ "$stored_date" != "$current_date" ]; then
            stored_accumulated=0
        fi
    else
        stored_accumulated=0
    fi

    echo "$stored_accumulated"
}

# Get and update the last recorded uptime for the current session
get_current_session_state() {
    local current_boot_time=$1
    local current_uptime=$2

    if [ -f "$CURRENT_SESSION_STATE" ] && [ -s "$CURRENT_SESSION_STATE" ]; then
        local stored_boot_time stored_last_uptime
        IFS=' ' read -r stored_boot_time stored_last_uptime < "$CURRENT_SESSION_STATE"

        # Check if it's the same boot session (same boot time)
        if [ "$stored_boot_time" = "$current_boot_time" ]; then
            # Same session, return the last uptime recorded
            echo "$stored_last_uptime"
        else
            # Different session (new boot), reset and return 0
            echo 0
        fi
    else
        # No file or empty, return 0
        echo 0
    fi
}

# Update the current session state
update_current_session_state() {
    local boot_time=$1
    local current_uptime=$2

    echo "$boot_time $current_uptime" > "$CURRENT_SESSION_STATE"
}

# Update accumulated uptime for the current day (only if larger than stored)
update_daily_accumulator() {
    local current_date
    current_date=$(date +%Y-%m-%d)
    local current_accumulated=$1

    # Check if there's already a stored value for today
    if [ -f "$DAILY_ACCUMULATOR" ] && [ -s "$DAILY_ACCUMULATOR" ]; then
        local stored_date stored_time
        IFS=' ' read -r stored_date stored_time < "$DAILY_ACCUMULATOR"

        # Only update if it's the same date and the new value is larger (or different date)
        if [ "$stored_date" = "$current_date" ]; then
            if [ "$current_accumulated" -gt "$stored_time" ]; then
                echo "$current_date $current_accumulated" > "$DAILY_ACCUMULATOR"
            fi
        else
            # Different date, so definitely update
            echo "$current_date $current_accumulated" > "$DAILY_ACCUMULATOR"
        fi
    else
        # No file or empty, create new entry
        echo "$current_date $current_accumulated" > "$DAILY_ACCUMULATOR"
    fi
}

# Get system boot time as Unix timestamp
get_boot_time() {
    local uptime_seconds
    uptime_seconds=$(awk '{print int($1)}' /proc/uptime)
    echo $(($(date +%s) - uptime_seconds))
}

# Get current uptime in seconds
get_uptime_seconds() {
    awk '{print int($1)}' /proc/uptime
}

# Convert seconds to HH:MM:SS format
seconds_to_hms() {
    local total_seconds=$1
    local hours=$((total_seconds / 3600))
    local minutes=$(((total_seconds % 3600) / 60))
    local seconds=$((total_seconds % 60))
    printf "%02d:%02d:%02d" "$hours" "$minutes" "$seconds"
}

# Get burn level for daily uptime (in seconds)
get_burn_level_daily() {
    local seconds=$1
    local hours=$((seconds / 3600))

    if [ "$hours" -lt 2 ]; then
        echo 1
    elif [ "$hours" -lt 6 ]; then
        echo 2
    elif [ "$hours" -lt 10 ]; then
        echo 3
    elif [ "$hours" -lt 14 ]; then
        echo 4
    else
        echo 5
    fi
}

# Get burn level for weekly uptime (in seconds)
get_burn_level_weekly() {
    local seconds=$1
    local hours=$((seconds / 3600))

    if [ "$hours" -lt 14 ]; then
        echo 1
    elif [ "$hours" -lt 42 ]; then
        echo 2
    elif [ "$hours" -lt 70 ]; then
        echo 3
    elif [ "$hours" -lt 98 ]; then
        echo 4
    else
        echo 5
    fi
}

# Get burn level for monthly uptime (in seconds)
get_burn_level_monthly() {
    local seconds=$1
    local hours=$((seconds / 3600))

    if [ "$hours" -lt 60 ]; then
        echo 1
    elif [ "$hours" -lt 180 ]; then
        echo 2
    elif [ "$hours" -lt 300 ]; then
        echo 3
    elif [ "$hours" -lt 420 ]; then
        echo 4
    else
        echo 5
    fi
}

# Get color for burn level
get_burn_color() {
    local level=$1
    case $level in
        1) printf '%b' "$COLOR_GREEN" ;;
        2) printf '%b' "$COLOR_YELLOW" ;;
        3) printf '%b' "$COLOR_ORANGE" ;;
        4) printf '%b' "$COLOR_RED" ;;
        5) printf '%b' "$COLOR_DARK_RED" ;;
        *) printf '%b' "$COLOR_RESET" ;;
    esac
}

# Get label for burn level
get_burn_label() {
    local level=$1
    case $level in
        1) echo "FreshUser ðŸŸ¢" ;;
        2) echo "CoffeeMode â˜•" ;;
        3) echo "SlightlyFried ðŸ³" ;;
        4) echo "BurnoutImminent ðŸ”¥" ;;
        5) echo "FullyCooked ðŸ’€" ;;
        *) echo "BURN-$level" ;;
    esac
}

# Log uptime (main logic)
log_uptime() {
    local boot_time current_time current_date uptime_seconds

    uptime_seconds=$(get_uptime_seconds)
    current_time=$(date +%s)
    boot_time=$((current_time - uptime_seconds))
    current_date=$(date +%Y-%m-%d)

    # Calculate the actual boot date
    local boot_date
    boot_date=$(date -d "@${boot_time}" +%Y-%m-%d)

    # Get previously accumulated time for today (before current boot)
    local prev_accumulated
    prev_accumulated=$(get_daily_accumulated_time)

    # Get the last recorded uptime for the current session to calculate increment
    local last_session_uptime
    last_session_uptime=$(get_current_session_state "$boot_time" "$uptime_seconds")

    # Calculate incremental time since last recording
    local incremental_time
    incremental_time=$((uptime_seconds - last_session_uptime))

    # If this is a new boot (last_session_uptime is 0), we can't use incremental approach
    if [ "$last_session_uptime" -eq 0 ]; then
        # This is a new boot session, so the accumulated time from before the boot is what we have
        # We'll add the current total uptime for this boot to the previous accumulated time
        incremental_time=$uptime_seconds
    elif [ "$incremental_time" -lt 0 ]; then
        # This means system time changed or we're in a new boot session
        # Treat it as a new boot session
        incremental_time=$uptime_seconds
    fi

    # Check if we need to handle multi-day uptime
    if [ "$boot_date" != "$current_date" ]; then
        handle_multiday_uptime "$boot_time" "$current_time" "$uptime_seconds"
    else
        # Simple case: boot and current time are on the same day
        # Calculate seconds for only this day (from when system started being active until now)
        local day_start
        day_start=$(date -d "${current_date} 00:00:00" +%s)

        # Calculate time from beginning of day to boot time (if booted today)
        local effective_boot_time
        effective_boot_time=$((boot_time > day_start ? boot_time : day_start))
        local current_boot_seconds=$((current_time - effective_boot_time))

        # Total accumulated time for the day (previous + current session)
        local total_day_seconds=$((prev_accumulated + current_boot_seconds))

        # Update the daily accumulator with the new total
        update_daily_accumulator "$total_day_seconds"

        # Update the session state for this boot
        update_current_session_state "$boot_time" "$uptime_seconds"

        # Update the log entry with the accumulated time for the day
        update_or_add_entry "$current_date" "$boot_time" "$current_time" "$total_day_seconds"
    fi
}

# Handle uptime spanning multiple days
handle_multiday_uptime() {
    local boot_time=$1
    local current_time=$2
    local total_uptime=$3

    local boot_date current_date
    boot_date=$(date -d "@${boot_time}" +%Y-%m-%d)
    current_date=$(date -d "@${current_time}" +%Y-%m-%d)

    # Generate all dates from boot to current
    local date_cursor=$boot_time
    local date_cursor_str

    while true; do
        date_cursor_str=$(date -d "@${date_cursor}" +%Y-%m-%d)

        # Calculate day boundaries
        local day_start day_end
        day_start=$(date -d "${date_cursor_str} 00:00:00" +%s)
        day_end=$(date -d "${date_cursor_str} 23:59:59" +%s)

        # Determine time range for this day
        local range_start range_end
        range_start=$((boot_time > day_start ? boot_time : day_start))
        range_end=$((current_time < day_end ? current_time : day_end))

        # Calculate seconds for this day
        local day_seconds=$((range_end - range_start))
        [ $day_seconds -lt 0 ] && day_seconds=0

        # For the current date, we need to add to any previously accumulated time
        if [ "$date_cursor_str" = "$current_date" ]; then
            local prev_accumulated
            prev_accumulated=$(get_daily_accumulated_time)
            day_seconds=$((day_seconds + prev_accumulated))
            # Update accumulator to reflect that we've now accounted for this time
            update_daily_accumulator "$day_seconds"
        fi

        # Update or add entry for this date
        update_or_add_entry "$date_cursor_str" "$boot_time" "$current_time" "$day_seconds"

        # Move to next day
        [ "$date_cursor_str" = "$current_date" ] && break
        date_cursor=$(date -d "${date_cursor_str} +1 day" +%s)
    done
}

# Update existing entry or add new one
update_or_add_entry() {
    local target_date=$1
    local boot_time=$2
    local current_time=$3
    local current_day_seconds=$4

    local temp_file="${LOG_FILE}.tmp"
    local found=0

    if [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]; then
        while IFS=' ' read -r log_date log_start log_last log_prev_total; do
            if [ "$log_date" = "$target_date" ]; then
                # For same date, simply update with the current accumulated value
                # The accumulation is now handled by the daily accumulator logic
                echo "$target_date $boot_time $current_time $current_day_seconds" >> "$temp_file"
                found=1
            else
                # Keep other entries as-is
                echo "$log_date $log_start $log_last $log_prev_total" >> "$temp_file"
            fi
        done < "$LOG_FILE"

        if [ $found -eq 0 ]; then
            # Append new entry
            echo "$target_date $boot_time $current_time $current_day_seconds" >> "$temp_file"
        fi

        mv "$temp_file" "$LOG_FILE"
    else
        # No log file or empty, create new entry
        echo "$target_date $boot_time $current_time $current_day_seconds" > "$LOG_FILE"
    fi
}

# Show daily summary
show_day() {
    local today
    today=$(date +%Y-%m-%d)
    local total_seconds=0
    
    if [ -f "$LOG_FILE" ]; then
        while IFS=' ' read -r log_date _ _ log_total; do
            if [ "$log_date" = "$today" ]; then
                total_seconds=$log_total
                break
            fi
        done < "$LOG_FILE"
    fi
    
    local burn_level
    burn_level=$(get_burn_level_daily "$total_seconds")
    local burn_color
    burn_color=$(get_burn_color "$burn_level")
    local burn_label
    burn_label=$(get_burn_label "$burn_level")
    local hms
    hms=$(seconds_to_hms "$total_seconds")
    
    printf "Today (%s): %s - %s%s%b\n" "$today" "$hms" "$burn_color" "$burn_label" "$COLOR_RESET"
}

# Show weekly summary
show_week() {
    local total_seconds=0
    local i
    
    for i in {6..0}; do
        local target_date
        target_date=$(date -d "-${i} days" +%Y-%m-%d)
        local day_seconds=0
        
        if [ -f "$LOG_FILE" ]; then
            while IFS=' ' read -r log_date _ _ log_total; do
                if [ "$log_date" = "$target_date" ]; then
                    day_seconds=$log_total
                    break
                fi
            done < "$LOG_FILE"
        fi
        
        local burn_level
        burn_level=$(get_burn_level_daily "$day_seconds")
        local burn_color
        burn_color=$(get_burn_color "$burn_level")
        local burn_label
        burn_label=$(get_burn_label "$burn_level")
        local hms
        hms=$(seconds_to_hms "$day_seconds")
        
        printf "%s %s %s%s%b\n" "$target_date" "$hms" "$burn_color" "$burn_label" "$COLOR_RESET"
        total_seconds=$((total_seconds + day_seconds))
    done
    
    local week_burn
    week_burn=$(get_burn_level_weekly "$total_seconds")
    local week_color
    week_color=$(get_burn_color "$week_burn")
    local week_label
    week_label=$(get_burn_label "$week_burn")
    local week_hms
    week_hms=$(seconds_to_hms "$total_seconds")
    
    printf "\n"
    printf "Weekly Total: %s - %s%s%b\n" "$week_hms" "$week_color" "$week_label" "$COLOR_RESET"
}

# Show monthly summary
show_month() {
    local month_total=0

    # Loop weeks from oldest to newest (4 weeks total)
    # Follow pattern similar to week but for 4 weeks instead of 7 days
    for week_back in {4..1}; do
        local week_seconds=0

        # Calculate the range for each week:
        # week_back = 4: 27-21 days ago (oldest)
        # week_back = 3: 20-14 days ago
        # week_back = 2: 13-7 days ago
        # week_back = 1: 6-0 days ago (most recent)
        local start_day=$((7 * week_back - 1))    # 27, 20, 13, 6 days ago
        local end_day=$((start_day - 6))          # 21, 14,  7, 0 days ago

        for i in $(seq $end_day $start_day); do
            local target_date
            target_date=$(date -d "-${i} days" +%Y-%m-%d)

            if [ -f "$LOG_FILE" ]; then
                while IFS=' ' read -r log_date _ _ log_total; do
                    if [ "$log_date" = "$target_date" ]; then
                        week_seconds=$((week_seconds + log_total))
                        break
                    fi
                done < "$LOG_FILE"
            fi
        done

        local burn_level
        burn_level=$(get_burn_level_weekly "$week_seconds")
        local burn_color
        burn_color=$(get_burn_color "$burn_level")
        local burn_label
        burn_label=$(get_burn_label "$burn_level")
        local hms
        hms=$(seconds_to_hms "$week_seconds")

        printf "Week %d: %s - %s%s%b\n" "$((5-week_back))" "$hms" "$burn_color" "$burn_label" "$COLOR_RESET"
        month_total=$((month_total + week_seconds))
    done

    local month_burn
    month_burn=$(get_burn_level_monthly "$month_total")
    local month_color
    month_color=$(get_burn_color "$month_burn")
    local month_label
    month_label=$(get_burn_label "$month_burn")
    local month_hms
    month_hms=$(seconds_to_hms "$month_total")

    printf "\n"
    printf "Monthly Total: %s - %s%s%b\n" "$month_hms" "$month_color" "$month_label" "$COLOR_RESET"
}

# Show help
show_help() {
    cat << EOF
upm - Uptime Monitor

Usage:
  upm              Log/update current uptime
  upm --day        Show today's uptime summary
  upm --week       Show weekly uptime summary (past 7 days)
  upm --month      Show monthly uptime summary (4 weeks)
  upm --help       Show this help message

Log file: ${LOG_FILE}
EOF
}

# Main
main() {
    init_upm
    
    case "${1:-}" in
        --day)
            show_day
            ;;
        --week)
            show_week
            ;;
        --month)
            show_month
            ;;
        --help)
            show_help
            ;;
        "")
            log_uptime
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
}

main "$@"